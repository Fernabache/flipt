// Code generated by protoc-gen-go-gateway-client. DO NOT EDIT.

package auth

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	status "google.golang.org/genproto/googleapis/rpc/status"
	status1 "google.golang.org/grpc/status"
	protojson "google.golang.org/protobuf/encoding/protojson"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	io "io"
	http "net/http"
	url "net/url"
)

type PublicAuthenticationServiceHTTPClient struct {
	client *http.Client
	addr   string
}

func (x *PublicAuthenticationServiceHTTPClient) ListAuthenticationMethods(ctx context.Context, v *emptypb.Empty) (*ListAuthenticationMethodsResponse, error) {
	var body io.Reader
	var values = url.Values{}
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, x.addr+"/auth/v1/method", body)
	if err != nil {
		return nil, err
	}
	req.URL.RawQuery = values.Encode()
	resp, err := x.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var output ListAuthenticationMethodsResponse
	respData, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	if err := checkResponse(resp, respData); err != nil {
		return nil, err
	}
	if err := protojson.Unmarshal(respData, &output); err != nil {
		return nil, err
	}
	return &output, nil
}

type AuthenticationServiceHTTPClient struct {
	client *http.Client
	addr   string
}

func (x *AuthenticationServiceHTTPClient) GetAuthenticationSelf(ctx context.Context, v *emptypb.Empty) (*Authentication, error) {
	var body io.Reader
	var values = url.Values{}
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, x.addr+"/auth/v1/self", body)
	if err != nil {
		return nil, err
	}
	req.URL.RawQuery = values.Encode()
	resp, err := x.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var output Authentication
	respData, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	if err := checkResponse(resp, respData); err != nil {
		return nil, err
	}
	if err := protojson.Unmarshal(respData, &output); err != nil {
		return nil, err
	}
	return &output, nil
}

func (x *AuthenticationServiceHTTPClient) GetAuthentication(ctx context.Context, v *GetAuthenticationRequest) (*Authentication, error) {
	var body io.Reader
	var values = url.Values{}
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, x.addr+fmt.Sprintf("/auth/v1/tokens/%v", v.Id), body)
	if err != nil {
		return nil, err
	}
	req.URL.RawQuery = values.Encode()
	resp, err := x.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var output Authentication
	respData, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	if err := checkResponse(resp, respData); err != nil {
		return nil, err
	}
	if err := protojson.Unmarshal(respData, &output); err != nil {
		return nil, err
	}
	return &output, nil
}

func (x *AuthenticationServiceHTTPClient) ListAuthentications(ctx context.Context, v *ListAuthenticationsRequest) (*ListAuthenticationsResponse, error) {
	var body io.Reader
	var values = url.Values{}
	values.Set("method", fmt.Sprintf("%v", v.Method))
	values.Set("limit", fmt.Sprintf("%v", v.Limit))
	values.Set("pageToken", v.PageToken)
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, x.addr+"/auth/v1/tokens", body)
	if err != nil {
		return nil, err
	}
	req.URL.RawQuery = values.Encode()
	resp, err := x.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var output ListAuthenticationsResponse
	respData, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	if err := checkResponse(resp, respData); err != nil {
		return nil, err
	}
	if err := protojson.Unmarshal(respData, &output); err != nil {
		return nil, err
	}
	return &output, nil
}

func (x *AuthenticationServiceHTTPClient) DeleteAuthentication(ctx context.Context, v *DeleteAuthenticationRequest) (*emptypb.Empty, error) {
	var body io.Reader
	var values = url.Values{}
	req, err := http.NewRequestWithContext(ctx, http.MethodDelete, x.addr+fmt.Sprintf("/auth/v1/tokens/%v", v.Id), body)
	if err != nil {
		return nil, err
	}
	req.URL.RawQuery = values.Encode()
	resp, err := x.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var output emptypb.Empty
	respData, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	if err := checkResponse(resp, respData); err != nil {
		return nil, err
	}
	if err := protojson.Unmarshal(respData, &output); err != nil {
		return nil, err
	}
	return &output, nil
}

func (x *AuthenticationServiceHTTPClient) ExpireAuthenticationSelf(ctx context.Context, v *ExpireAuthenticationSelfRequest) (*emptypb.Empty, error) {
	var body io.Reader
	var values = url.Values{}
	values.Set("expiresAt", fmt.Sprintf("%v", v.ExpiresAt))
	req, err := http.NewRequestWithContext(ctx, http.MethodPut, x.addr+"/auth/v1/self/expire", body)
	if err != nil {
		return nil, err
	}
	req.URL.RawQuery = values.Encode()
	resp, err := x.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var output emptypb.Empty
	respData, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	if err := checkResponse(resp, respData); err != nil {
		return nil, err
	}
	if err := protojson.Unmarshal(respData, &output); err != nil {
		return nil, err
	}
	return &output, nil
}

type AuthenticationMethodTokenServiceHTTPClient struct {
	client *http.Client
	addr   string
}

func (x *AuthenticationMethodTokenServiceHTTPClient) CreateToken(ctx context.Context, v *CreateTokenRequest) (*CreateTokenResponse, error) {
	var body io.Reader
	var values = url.Values{}
	reqData, err := protojson.Marshal(v)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqData)
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, x.addr+"/auth/v1/method/token", body)
	if err != nil {
		return nil, err
	}
	req.URL.RawQuery = values.Encode()
	resp, err := x.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var output CreateTokenResponse
	respData, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	if err := checkResponse(resp, respData); err != nil {
		return nil, err
	}
	if err := protojson.Unmarshal(respData, &output); err != nil {
		return nil, err
	}
	return &output, nil
}

type AuthenticationMethodOIDCServiceHTTPClient struct {
	client *http.Client
	addr   string
}

func (x *AuthenticationMethodOIDCServiceHTTPClient) AuthorizeURL(ctx context.Context, v *AuthorizeURLRequest) (*AuthorizeURLResponse, error) {
	var body io.Reader
	var values = url.Values{}
	values.Set("state", v.State)
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, x.addr+fmt.Sprintf("/auth/v1/method/oidc/%v/authorize", v.Provider), body)
	if err != nil {
		return nil, err
	}
	req.URL.RawQuery = values.Encode()
	resp, err := x.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var output AuthorizeURLResponse
	respData, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	if err := checkResponse(resp, respData); err != nil {
		return nil, err
	}
	if err := protojson.Unmarshal(respData, &output); err != nil {
		return nil, err
	}
	return &output, nil
}

func (x *AuthenticationMethodOIDCServiceHTTPClient) Callback(ctx context.Context, v *CallbackRequest) (*CallbackResponse, error) {
	var body io.Reader
	var values = url.Values{}
	values.Set("code", v.Code)
	values.Set("state", v.State)
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, x.addr+fmt.Sprintf("/auth/v1/method/oidc/%v/callback", v.Provider), body)
	if err != nil {
		return nil, err
	}
	req.URL.RawQuery = values.Encode()
	resp, err := x.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var output CallbackResponse
	respData, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	if err := checkResponse(resp, respData); err != nil {
		return nil, err
	}
	if err := protojson.Unmarshal(respData, &output); err != nil {
		return nil, err
	}
	return &output, nil
}

type AuthenticationMethodKubernetesServiceHTTPClient struct {
	client *http.Client
	addr   string
}

func (x *AuthenticationMethodKubernetesServiceHTTPClient) VerifyServiceAccount(ctx context.Context, v *VerifyServiceAccountRequest) (*VerifyServiceAccountResponse, error) {
	var body io.Reader
	var values = url.Values{}
	reqData, err := protojson.Marshal(v)
	if err != nil {
		return nil, err
	}
	body = bytes.NewReader(reqData)
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, x.addr+"/auth/v1/method/kubernetes/serviceaccount", body)
	if err != nil {
		return nil, err
	}
	req.URL.RawQuery = values.Encode()
	resp, err := x.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	var output VerifyServiceAccountResponse
	respData, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	if err := checkResponse(resp, respData); err != nil {
		return nil, err
	}
	if err := protojson.Unmarshal(respData, &output); err != nil {
		return nil, err
	}
	return &output, nil
}

func checkResponse(resp *http.Response, v []byte) error {
	if resp.StatusCode != http.StatusOK {
		var status status.Status
		if err := protojson.Unmarshal(v, &status); err != nil {
			return err
		}
		return status1.ErrorProto(&status)
	}

	return nil
}
